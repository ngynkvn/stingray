package stingray

import (
  "github.com/ngynkvn/stingray/deadlock"
  "github.com/golang/protobuf/proto"
)

// Callbacks decodes and routes replay events to callback functions
type Callbacks struct {
{{ range .DemoTypes }}  on{{ .Callback }} []func(*deadlock.{{ .TypeName }}) error
{{ end }}{{ range .PacketTypes }}  on{{ .Callback }} []func(*deadlock.{{ .TypeName }}) error
{{ end }}
  pb *proto.Buffer
}

func newCallbacks() *Callbacks {
  return &Callbacks{
    pb: &proto.Buffer{},
  }
}

{{ range .DemoTypes }}// On{{ .Callback }} registers a callback {{ .EnumName }}
func(c *Callbacks) On{{ .Callback }}(fn func(*deadlock.{{ .TypeName }}) error) {
  c.on{{ .Callback }} = append(c.on{{ .Callback }}, fn)
}
{{ end }}{{ range .PacketTypes }}// On{{ .Callback }} registers a callback for {{ .EnumName }}
func(c *Callbacks) On{{ .Callback }}(fn func(*deadlock.{{ .TypeName }}) error) {
  c.on{{ .Callback }} = append(c.on{{ .Callback }}, fn)
}
{{ end }}

func (c *Callbacks) callByDemoType(t int32, buf []byte) error {
  switch t {
{{ range .DemoTypes }}  case {{ .Id }}: // deadlock.{{ .EnumName }}
    if c.on{{ .Callback }} == nil {
      return nil
    }

    msg := &deadlock.{{ .TypeName }}{}
    c.pb.SetBuf(buf)
    if err := c.pb.Unmarshal(msg); err != nil {
      return err
    }

    for _, fn := range c.on{{ .Callback }} {
      if err := fn(msg); err != nil {
        return err
      }
    }

    return nil

{{ end }}
  }

  if v(1) {
    _debugf("warning: no demo type %d found", t)
  }

  return nil
}

// TODO: Cleanup
func (c *Callbacks) getDemoTypeName(t int32) string {
  switch t {
{{ range .DemoTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
  return "{{ .EnumName }}"
{{ end }}
  }
  return "UNKNOWN"
}

// TODO: Cleanup
func (c *Callbacks) toDemoString(t int32, buf []byte) string {
  switch t {
{{ range .DemoTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
    msg := &deadlock.{{ .TypeName }}{}
    c.pb.SetBuf(buf)
    if err := c.pb.Unmarshal(msg); err != nil {
      return "ERROR"
    }
    return msg.String()
{{ end }}
  }
  return "UNKNOWN"
}


// TODO: Cleanup
func (c *Callbacks) getPacketTypeName(t int32) string {
  switch t {
{{ range .PacketTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
    return "{{ .EnumName }}"
{{ end }}
  }
    return "UNKNOWN"
}

// TODO: Cleanup
func (c *Callbacks) toPacketString(t int32, buf []byte) string {
  switch t {
{{ range .PacketTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
    msg := &deadlock.{{ .TypeName }}{}
    c.pb.SetBuf(buf)
    if err := c.pb.Unmarshal(msg); err != nil {
      return "ERROR"
    }
    return msg.String()
{{ end }}
  }
  return "UNKNOWN"
}



func (c *Callbacks) callByPacketType(t int32, buf []byte) error {
  switch t {
{{ range .PacketTypes }}  case {{ .Id }}: // deadlock.{{ .EnumName }}
    if c.on{{ .Callback }} == nil {
      return nil
    }

    msg := &deadlock.{{ .TypeName }}{}
    c.pb.SetBuf(buf)
    if err := c.pb.Unmarshal(msg); err != nil {
      return err
    }

    for _, fn := range c.on{{ .Callback }} {
      if err := fn(msg); err != nil {
        return err
      }
    }

    return nil

{{ end }}
  }

  return nil
}
