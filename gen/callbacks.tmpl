// Code generated by gen/callbacks.go"; DO NOT EDIT.
package stingray

import (
  "github.com/ngynkvn/stingray/deadlock"
  "google.golang.org/protobuf/proto"
  "google.golang.org/protobuf/encoding/prototext"
  "strconv"
)

// Callbacks decodes and routes replay events to callback functions
type Callbacks struct {
{{ range .DemoTypes }}  on{{ .Callback }} []func(*deadlock.{{ .TypeName }}) error
{{ end }}{{ range .PacketTypes }}  on{{ .Callback }} []func(*deadlock.{{ .TypeName }}) error
{{ end }}
}

func newCallbacks() *Callbacks {
  return &Callbacks{
  }
}

{{ range .DemoTypes }}// On{{ .Callback }} registers a callback {{ .EnumName }}
func(c *Callbacks) On{{ .Callback }}(fn func(*deadlock.{{ .TypeName }}) error) {
  c.on{{ .Callback }} = append(c.on{{ .Callback }}, fn)
}
{{ end }}{{ range .PacketTypes }}// On{{ .Callback }} registers a callback for {{ .EnumName }}
func(c *Callbacks) On{{ .Callback }}(fn func(*deadlock.{{ .TypeName }}) error) {
  c.on{{ .Callback }} = append(c.on{{ .Callback }}, fn)
}
{{ end }}

func (c *Callbacks) callByDemoType(t int32, buf []byte) error {
  switch t {
{{ range .DemoTypes }}  case {{ .Id }}: // deadlock.{{ .EnumName }}
    if c.on{{ .Callback }} == nil {
      return nil
    }

    msg := &deadlock.{{ .TypeName }}{}
    if err := proto.Unmarshal(buf, msg); err != nil {
      return err
    }

    for _, fn := range c.on{{ .Callback }} {
      if err := fn(msg); err != nil {
        return err
      }
    }

    return nil

{{ end }}
  }

  _dbg.Warn("Demo type not found",
      "type", t)

  return nil
}

// TODO: Cleanup
func (c *Callbacks) getDemoTypeName(t int32) string {
  switch t {
{{ range .DemoTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
  return "{{ .EnumName }}"
{{ end }}
  }
  return "UNKNOWN:"+strconv.Itoa(int(t))
}

// TODO: Cleanup
func (c *Callbacks) toDemoString(t int32, buf []byte) string {
  switch t {
{{ range .DemoTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
    msg := &deadlock.{{ .TypeName }}{}
    if err := proto.Unmarshal(buf, msg); err != nil {
      return "ERROR"
    }
    return prototext.Format(msg)
{{ end }}
  }
  return "UNKNOWN:"+strconv.Itoa(int(t))
}


// TODO: Cleanup
func (c *Callbacks) getPacketTypeName(t int32) string {
  switch t {
{{ range .PacketTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
    return "{{ .EnumName }}"
{{ end }}
  }
  return "UNKNOWN:"+strconv.Itoa(int(t))
}

// TODO: Cleanup
func (c *Callbacks) toPacketString(t int32, buf []byte) string {
  switch t {
{{ range .PacketTypes }} case {{ .Id }}: //deadlock.{{ .EnumName }}
    msg := &deadlock.{{ .TypeName }}{}
    if err := proto.Unmarshal(buf, msg); err != nil {
      return "ERROR"
    }
    return prototext.Format(msg)
{{ end }}
  }
  return "UNKNOWN:"+strconv.Itoa(int(t))
}



func (c *Callbacks) callByPacketType(t int32, buf []byte) error {
  switch t {
{{ range .PacketTypes }}  case {{ .Id }}: // deadlock.{{ .EnumName }}
    if c.on{{ .Callback }} == nil {
      return nil
    }

    msg := &deadlock.{{ .TypeName }}{}
    if err := proto.Unmarshal(buf, msg); err != nil {
      return err
    }

    for _, fn := range c.on{{ .Callback }} {
      if err := fn(msg); err != nil {
        return err
      }
    }

    return nil

{{ end }}
  }

  return nil
}
